<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        .container {
            text-align: center;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .error {
            color: red;
            font-weight: bold;
        }

    </style>
</head>
<body>
    <div class="container">
        <p class="error" id="gpuDeviceLostError"></p>
        <h1>Web GPU</h1>
        <p class="error" id="error"></p>
        <p id="gpuInfo"></p>
        <button class="primarybutton" id="computeButton" onclick="exampleCompute()" disabled>Initializing</button>
    </div>
    <script>
        let device;
        let error = document.getElementById("error")
        console.log("WebGPU demo page loaded");
        const handlePotentialDeviceLost = (promise) => {
            if (!promise) {
                throw new Error("handleLostDevice received null")
            }
            promise.then(info => {
                GPU_DEVICE_LOST = "GPU device was lost. Behaviour may be undefined, restart the page"
                console.error(GPU_DEVICE_LOST)
                document.getElementById("gpuDeviceLostError").textContent = `Fatal error: ${GPU_DEVICE_LOST}`
            })
        }
        const init = async () => {
            try {
                if (!navigator.gpu) {
                    console.error("Navigator.gpu is null")
                    throw new Error("Web GPU not supported")
                }
                const adapter = await navigator.gpu.requestAdapter()
                if (!adapter) {
                    console.error("requestAdapter returned null")
                    throw new Error("Unable to get GPU device")
                }
                adapter.requestAdapterInfo().then(({vendor, architecture}) => {
                    document.getElementById("gpuInfo").textContent = `Device: ${vendor} ${architecture}`
                })
                let _device = await adapter.requestDevice()
                handlePotentialDeviceLost(_device.lost)
                const computeButton = document.getElementById("computeButton")
                computeButton.disabled = false;
                computeButton.textContent = "Compute"
                device = _device;
            }
            catch (e) {
                console.error("init error", e)
                mainError.textContent = `Initialization error: ${e.message}`;
            }
        }
        init()

        const createBufferInit = (
            device,
            descriptor,
        )=> {
            const contents = new Uint8Array(descriptor.contents);

            const alignMask = 4 - 1;
            const paddedSize = Math.max(
                (contents.byteLength + alignMask) & ~alignMask,
                4,
            );

            const buffer = device.createBuffer({
                label: descriptor.label,
                usage: descriptor.usage,
                mappedAtCreation: true,
                size: paddedSize,
            });
            const data = new Uint8Array(buffer.getMappedRange());
            data.set(contents);
            buffer.unmap();
            return buffer;
        }

        const exampleCompute = async () => {
            try {
                if (!device) {
                    throw new Error("Device is not set up")
                }
                const OVERFLOW = 0xffffffff;

                // Get some numbers from the command line, or use the default 1, 4, 3, 295.
                let numbers;
                numbers = new Uint32Array([1, 4, 3, 295]);

                const shaderCode = `
                @group(0)
                @binding(0)
                var<storage, read_write> v_indices: array<u32>; // this is used as both input and output for convenience

                fn collatz_iterations(n_base: u32) -> u32{
                    var n: u32 = n_base;
                    var i: u32 = 0u;
                    loop {
                        if (n <= 1u) {
                            break;
                        }
                        if (n % 2u == 0u) {
                            n = n / 2u;
                        }
                        else {
                            // Overflow? (i.e. 3*n + 1 > 0xffffffffu?)
                            if (n >= 1431655765u) {   // 0x55555555u
                                return 4294967295u;   // 0xffffffffu
                            }

                            n = 3u * n + 1u;
                        }
                        i = i + 1u;
                    }
                    return i;
                }

                @compute
                @workgroup_size(1)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    v_indices[global_id.x] = collatz_iterations(v_indices[global_id.x]);
                }
                `;

                const shaderModule = device.createShaderModule({
                    code: shaderCode,
                });

                const stagingBuffer = device.createBuffer({
                    size: numbers.byteLength,
                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
                });

                const storageBuffer = createBufferInit(device, {
                    label: "Storage Buffer",
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST |
                        GPUBufferUsage.COPY_SRC,
                    contents: numbers.buffer,
                });

                const computePipeline = device.createComputePipeline({
                    layout: "auto",
                    compute: {
                        module: shaderModule,
                        entryPoint: "main",
                    },
                });

                const bindGroupLayout = computePipeline.getBindGroupLayout(0);
                const bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        {
                        binding: 0,
                        resource: {
                            buffer: storageBuffer,
                        },
                        },
                    ],
                });

                const encoder = device.createCommandEncoder();

                const computePass = encoder.beginComputePass();
                computePass.setPipeline(computePipeline);
                computePass.setBindGroup(0, bindGroup);
                computePass.insertDebugMarker("compute collatz iterations");
                computePass.dispatchWorkgroups(numbers.length);
                computePass.end();

                encoder.copyBufferToBuffer(
                    storageBuffer,
                    0,
                    stagingBuffer,
                    0,
                    numbers.byteLength,
                );

                device.queue.submit([encoder.finish()]);

                await stagingBuffer.mapAsync(1);
                const arrayBufferData = stagingBuffer.getMappedRange();
                const uintData = new Uint32Array(arrayBufferData);
                const checkedData = Array.from(uintData).map((n) => {
                if (n === OVERFLOW) {
                    return "OVERFLOW";
                } else {
                    return n.toString();
                }
                });
                console.log(checkedData);
                stagingBuffer.unmap();

            } catch (e) {
                console.error("compute error", e)
                mainError.textContent = `Compute error: ${e.message}`
            }
        }
       
    </script>
</body>
</html>
