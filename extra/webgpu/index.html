<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Demo</title>
    <style>
        h1, p {
            margin: 10px;
        }
        button {
            margin: 10px;
        }
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 300px;
            text-align: start;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .error {
            color: red;
            font-weight: bold;
        }
        .primaryButton {
            padding: 10px;
            display: block;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }
        .primaryButton:hover {
            background-color: #45a049;
        }
        .primaryButton:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
        }

    </style>
</head>
<body>
    <div class="container">
        <p class="error" id="gpuDeviceLostError"></p>
        <h1>Web GPU</h1>
        <p class="error" id="error"></p>
        <p id="gpuInfo"></p>
        <p id="serverAddress"></p>
        <p id="connectionStatus">ðŸ”´ offline</p>
        <button class="primaryButton" id="connect" onclick="wsInit()">Connect to server</button>
        <button class="primaryButton" id="start" onclick="" disabled>Start</button>
    </div>
    <script>
        const address = "ws://localhost:8766"
        let device;
        let error = document.getElementById("error")
        const setError = (e, prefix) => {
            console.error(`${prefix} error`, e)
            error.textContent = `${prefix} error: ${e.message}`;
        }
        const makeStartButtonReady = () => {
            const start = document.getElementById("start")
            start.disabled = false;
        }
        const handlePotentialDeviceLost = (promise) => {
            if (!promise) {
                throw new Error("handleLostDevice received null")
            }
            promise.then(info => {
                GPU_DEVICE_LOST = "GPU device was lost. Behaviour may be undefined, restart the page"
                console.error(GPU_DEVICE_LOST)
                document.getElementById("gpuDeviceLostError").textContent = `Fatal error: ${GPU_DEVICE_LOST}`
            })
        }
        const deviceInit = async () => {
            try {
                document.getElementById("serverAddress").textContent = `Server: ${address}`
                if (!navigator.gpu) {
                    console.error("Navigator.gpu is null")
                    throw new Error("Web GPU not supported")
                }
                const adapter = await navigator.gpu.requestAdapter()
                if (!adapter) {
                    console.error("requestAdapter returned null")
                    throw new Error("Unable to get GPU device")
                }
                adapter.requestAdapterInfo().then(({vendor, architecture}) => {
                    document.getElementById("gpuInfo").textContent = `Device: ${vendor} ${architecture}`
                })
                let _device = await adapter.requestDevice()
                handlePotentialDeviceLost(_device.lost)
                device = _device;
            }
            catch (e) {
               setError(e, "Device initialization")
            }
        }

        const createBufferInit = (device,descriptor)=> {
            const contents = new Uint8Array(descriptor.contents);
            const alignMask = 4 - 1;
            const paddedSize = Math.max(
                (contents.byteLength + alignMask) & ~alignMask,
                4,
            );

            const buffer = device.createBuffer({
                label: descriptor.label,
                usage: descriptor.usage,
                mappedAtCreation: true,
                size: paddedSize,
            });
            const data = new Uint8Array(buffer.getMappedRange());
            data.set(contents);
            buffer.unmap();
            return buffer;
        }

        const exampleCompute = async () => {
            try {
                if (!device) {
                    throw new Error("Device is not set up")
                }
                const OVERFLOW = 0xffffffff;

                // Get some numbers from the command line, or use the default 1, 4, 3, 295.
                let numbers;
                numbers = new Uint32Array([1, 4, 3, 295]);

                const shaderCode = `
                @group(0)
                @binding(0)
                var<storage, read_write> v_indices: array<u32>; // this is used as both input and output for convenience

                fn collatz_iterations(n_base: u32) -> u32{
                    var n: u32 = n_base;
                    var i: u32 = 0u;
                    loop {
                        if (n <= 1u) {
                            break;
                        }
                        if (n % 2u == 0u) {
                            n = n / 2u;
                        }
                        else {
                            // Overflow? (i.e. 3*n + 1 > 0xffffffffu?)
                            if (n >= 1431655765u) {   // 0x55555555u
                                return 4294967295u;   // 0xffffffffu
                            }

                            n = 3u * n + 1u;
                        }
                        i = i + 1u;
                    }
                    return i;
                }

                @compute
                @workgroup_size(1)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    v_indices[global_id.x] = collatz_iterations(v_indices[global_id.x]);
                }
                `;

                const shaderModule = device.createShaderModule({
                    code: shaderCode,
                });

                const stagingBuffer = device.createBuffer({
                    size: numbers.byteLength,
                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
                });

                const storageBuffer = createBufferInit(device, {
                    label: "Storage Buffer",
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST |
                        GPUBufferUsage.COPY_SRC,
                    contents: numbers.buffer,
                });

                const computePipeline = device.createComputePipeline({
                    layout: "auto",
                    compute: {
                        module: shaderModule,
                        entryPoint: "main",
                    },
                });

                const bindGroupLayout = computePipeline.getBindGroupLayout(0);
                const bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        {
                        binding: 0,
                        resource: {
                            buffer: storageBuffer,
                        },
                        },
                    ],
                });

                const encoder = device.createCommandEncoder();

                const computePass = encoder.beginComputePass();
                computePass.setPipeline(computePipeline);
                computePass.setBindGroup(0, bindGroup);
                computePass.insertDebugMarker("compute collatz iterations");
                computePass.dispatchWorkgroups(numbers.length);
                computePass.end();

                encoder.copyBufferToBuffer(
                    storageBuffer,
                    0,
                    stagingBuffer,
                    0,
                    numbers.byteLength,
                );

                device.queue.submit([encoder.finish()]);

                await stagingBuffer.mapAsync(1);
                const arrayBufferData = stagingBuffer.getMappedRange();
                const uintData = new Uint32Array(arrayBufferData);
                const checkedData = Array.from(uintData).map((n) => {
                if (n === OVERFLOW) {
                    return "OVERFLOW";
                } else {
                    return n.toString();
                }
                });
                console.log(checkedData);
                stagingBuffer.unmap();

            } catch (e) {
                setError(e, "Example compute")
            }
        }
       
        const handleServerCommands = (data) => {

        }
        const wsInit = () => new Promise((res, rej) => {
            const timeoutId = setTimeout(() => {
                rej(new Error("Websocket timeout. Currently only supports single client, is another tab using it already?"))
            }, 5000)
            
            const socket = new WebSocket(address);
            // Listen for messages
            socket.addEventListener("message", (event) => {
                console.log("Message from server ", event.data, typeof(event.data));
            });
            socket.addEventListener("error", () => {
                setError(new Error("Unable to establish connection"), "Websocket initialization")
            })
            socket.addEventListener("open", () => {
                console.log("Connection established")
                clearTimeout(timeoutId)
                document.getElementById("connectionStatus").textContent = `ðŸŸ¢ online`
                
                socket.send("YO")
                document.getElementById("connect").disabled = true
                document.getElementById("connect").textContent = "Connected"
                makeStartButtonReady()
                res(true)
            })
            socket.addEventListener("close", () => {
                console.log("Disconnected")
                document.getElementById("connectionStatus").textContent = ``
            })
        }).catch((e) => setError(e, "WS"))

        const main = async () => {
            await deviceInit()
        }
        main()
    </script>
</body>
</html>
