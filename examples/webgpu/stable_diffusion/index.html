<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
#result {  font-size: 48px; }
#time {  font-size: 16px;  color: grey; }
#mybox {  padding: 20px; }
#resultbox {  padding: 50px; }
.bigggg {  font-size: 18px;  margin-top: 10px; }
.bigg {  font-size: 18px; }
#url {  font-size: 18px;  width: 70%; }
a {  text-decoration: none; }
h1 {  padding: 50px;  padding-bottom: 0px;  font-size: 36px;  font-weight: normal; }
#video {  height:0px;  width:0px;  border: 1px dotted black;  object-fit: cover;}

* {  text-align: center;  font-family: monospace; }
</style>
<title>tinygrad has WebGPU</title>

<script type="module">
    import ClipTokenizer from './clip_tokenizer.js';
    window.clipTokenizer = new ClipTokenizer();
</script>

<script src="./alphas_cumprod.js"></script>
<script src="./net.js"></script>
</head>
<body>
<h1>WebGPU <a href="https://github.com/geohot/tinygrad">tinygrad</a> StableDiffusion!</h1>
<div id="mybox">
<input type="text" id="prompt" placeholder="write your prompt here" value="a horse sized cat eating a bagel" hidden>
<input id="prompt_text" type="text" placeholder="Enter your prompt here">
<input id="step_range" type="range" min="1" max="20" value="10" step="1">
<input id="btnRunNet" class="bigg" type="button"  value="Run">
</div>
<br/>
<canvas id="canvas" width="512" height="512"> </canvas>
<div id="resultbox">
<div id="result">result will go here</div>
<div id="time"></div>
</div>
<script>
    window.addEventListener('load', function() {
        const ctx = document.getElementById("canvas").getContext("2d", { willReadFrequently: true });
        const resultText = document.getElementById('result');
        let labels, nets;

        const error = (err) => {
            resultText.innerHTML = `Error: ${err}`;
            throw new Error(err);
        }

        const getDevice = async () => {
            if (!navigator.gpu) error("WebGPU not supported.");
            const adapter = await navigator.gpu.requestAdapter();
            const requiredLimits = {};
            const maxBufferSizeInSDModel = 1073741824;
            requiredLimits.maxStorageBufferBindingSize = maxBufferSizeInSDModel;
            requiredLimits.maxBufferSize = maxBufferSizeInSDModel;
            
            return await adapter.requestDevice({
            requiredLimits,
            }	);
        };

        const timer = async (func, label = "") => {
            document.getElementById('time').innerHTML = "";
            const start = performance.now();
            const out = await func();
            const delta = (performance.now() - start).toFixed(1)
            console.log(`${delta} ms ${label}`);
            document.getElementById('time').innerHTML = `${delta} ms ${label}`;
            return out;
        }	

        function checkStatus(response) {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status} - ${response.statusText}`);
            }
            return response;
        }

        const loadNet = async () => {
            resultText.innerHTML = "loading..."
            const safetensorParts = await getSafetensorParts();
            const device = await getDevice();

            nets = await timer(() => Promise.all([
                text_modelModel().setup(device, safetensorParts),
                diffusorModel().setup(device, safetensorParts),
                get_x_prev_and_pred_x0Model().setup(device, safetensorParts),
                decoderModel().setup(device, safetensorParts)]
            ), "(compilation)")
            console.log(nets)
            resultText.innerHTML = "ready"
        }

        function runStableDiffusion(prompt) {
            return new Promise(async (resolve, reject) => {
                let prompt_encoded = clipTokenizer.encodeForCLIP(prompt);
                let context = await timer(() => nets[0](prompt_encoded));
                context = context.subarray(0, context.length/4);

                prompt_encoded = clipTokenizer.encodeForCLIP("");
                let unconditional_context = await timer(() => nets[0](prompt_encoded));
                unconditional_context = unconditional_context.subarray(0, unconditional_context.length/4);

                let timesteps = [];
                let steps = 10;

                for (let i = 1; i < 1000; i += (1000/steps)) {
                    timesteps.push(i);
                }

                console.log("Timesteps: " + timesteps);

                let alphasCumprod = window.alphas_cumprod;
                let alphas = [];

                for (t of timesteps) {
                    alphas.push(alphasCumprod[Math.floor(t)]);
                }

                alphas_prev = [1.0];

                for (let i = 0; i < alphas.length-1; i++) {
                    alphas_prev.push(alphas[i]);
                }

                let inpSize = 4*64*64;
                latent = new Float32Array(inpSize);

                for (let i = 0; i < inpSize; i++) {
                    latent[i] = Math.sqrt(-2.0 * Math.log(Math.random())) * Math.cos(2.0 * Math.PI * Math.random());
                }
                
                for (let i = timesteps.length - 1; i >= 0; i--) {
                    let timestep = new Float32Array([timesteps[i]]);
                    let e_t = await timer(() => nets[1](latent, timestep, unconditional_context, context));
                    e_t = e_t.subarray(0, e_t.length/4);
                    let x_prev = await timer(() => nets[2](latent, e_t, new Float32Array([alphas[i]]), new Float32Array([alphas_prev[i]])));
                    x_prev = x_prev.subarray(0, x_prev.length/4);
                    latent = x_prev;
                }
                
                resolve(await timer(() => nets[3](latent)));
            });
        }

        document.getElementById("btnRunNet").addEventListener("click", function(e) {
            if (!nets || nets.length != 4) error("Net not loaded yet.");
                runStableDiffusion(document.getElementById("prompt_text").value).then((image) => {
                    let pixels = []
                    let pixelCounter = 0

                    for (let j = 0; j < 512; j++) {
                        for (let k = 0; k < 512; k++) {
                            pixels.push(image[pixelCounter])
                            pixels.push(image[pixelCounter+1])
                            pixels.push(image[pixelCounter+2])
                            pixels.push(255)
                            pixelCounter += 3
                        }
                    }
                    
                    ctx.putImageData(new ImageData(new Uint8ClampedArray(pixels), 512, 512), 0, 0);
                    console.log(image);
                    console.log("Success");
                });
            }, false);

            loadNet();
        }
    )
</script>
</body>
</html>
